-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\gm_Moving_Average_sim\Moving_Average.vhd
-- Created: 2025-09-08 20:52:44
-- 
-- Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 0.0001
-- Target subsystem base rate: 0.0001
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        0.0001
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- Output                        ce_out        0.0001
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Moving_Average
-- Source Path: gm_Moving_Average_sim/Moving Average
-- Hierarchy Level: 0
-- Model version: 1.2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Moving_Average_pkg.ALL;

ENTITY Moving_Average IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        Input                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
        ce_out                            :   OUT   std_logic;
        Output                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
        );
END Moving_Average;


ARCHITECTURE rtl OF Moving_Average IS

  -- Component Declarations
  COMPONENT Rate_Transition
    PORT( in_rsvd                         :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          out_rsvd                        :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  COMPONENT Gain2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          Out1                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  COMPONENT Sum
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          In2                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          Out1                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  COMPONENT Gain_unaryminus
    PORT( In1                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          Out1                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  COMPONENT Sum1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          In2                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          Out1                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  COMPONENT Gain1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          Out1                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  COMPONENT Sum2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          In2                             :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          Out1                            :   OUT   std_logic_vector(63 DOWNTO 0)  -- double
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Rate_Transition
    USE ENTITY work.Rate_Transition(rtl);

  FOR ALL : Gain2
    USE ENTITY work.Gain2(rtl);

  FOR ALL : Sum
    USE ENTITY work.Sum(rtl);

  FOR ALL : Gain_unaryminus
    USE ENTITY work.Gain_unaryminus(rtl);

  FOR ALL : Sum1
    USE ENTITY work.Sum1(rtl);

  FOR ALL : Gain1
    USE ENTITY work.Gain1(rtl);

  FOR ALL : Sum2
    USE ENTITY work.Sum2(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Rate_Transition_out              : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL delayMatch_reg                   : vector_of_std_logic_vector64(0 TO 1);  -- ufix64 [2]
  SIGNAL delayMatch_out1                  : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Gain2_Out1                       : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Sum_Out1                         : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Gain_unaryminus_Out1             : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL delayMatch1_reg                  : vector_of_std_logic_vector64(0 TO 10);  -- ufix64 [11]
  SIGNAL delayMatch1_out1                 : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Sum1_Out1                        : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Gain1_Out1                       : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL delayMatch2_reg                  : vector_of_std_logic_vector64(0 TO 19);  -- ufix64 [20]
  SIGNAL delayMatch2_out1                 : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Sum2_Out1                        : std_logic_vector(63 DOWNTO 0);  -- ufix64

BEGIN
  u_Rate_Transition : Rate_Transition
    PORT MAP( in_rsvd => Input,  -- double
              out_rsvd => Rate_Transition_out  -- double
              );

  u_Gain2 : Gain2
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => Rate_Transition_out,  -- double
              Out1 => Gain2_Out1  -- double
              );

  u_Sum : Sum
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => delayMatch_out1,  -- double
              In2 => Gain2_Out1,  -- double
              Out1 => Sum_Out1  -- double
              );

  u_Gain_unaryminus : Gain_unaryminus
    PORT MAP( In1 => Gain2_Out1,  -- double
              Out1 => Gain_unaryminus_Out1  -- double
              );

  u_Sum1 : Sum1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => Sum_Out1,  -- double
              In2 => delayMatch1_out1,  -- double
              Out1 => Sum1_Out1  -- double
              );

  u_Gain1 : Gain1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => Gain_unaryminus_Out1,  -- double
              Out1 => Gain1_Out1  -- double
              );

  u_Sum2 : Sum2
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => Sum1_Out1,  -- double
              In2 => delayMatch2_out1,  -- double
              Out1 => Sum2_Out1  -- double
              );

  enb <= clk_enable;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => X"0000000000000000");
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= Rate_Transition_out;
        delayMatch_reg(1) <= delayMatch_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  delayMatch_out1 <= delayMatch_reg(1);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => X"0000000000000000");
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= Gain_unaryminus_Out1;
        delayMatch1_reg(1 TO 10) <= delayMatch1_reg(0 TO 9);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  delayMatch1_out1 <= delayMatch1_reg(10);

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch2_reg <= (OTHERS => X"0000000000000000");
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch2_reg(0) <= Gain1_Out1;
        delayMatch2_reg(1 TO 19) <= delayMatch2_reg(0 TO 18);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  delayMatch2_out1 <= delayMatch2_reg(19);

  Output <= Sum2_Out1;

  ce_out <= clk_enable;

END rtl;

