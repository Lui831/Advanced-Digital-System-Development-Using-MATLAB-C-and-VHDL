-- -------------------------------------------------------------
-- 
-- File Name: C:\ex_PINN_Matlab\codegen\prediction_v2\hdlsrc\prediction_v2_fixpt_tb.vhd
-- Created: 2025-11-17 12:33:59
-- 
-- Generated by MATLAB 25.2, MATLAB Coder 25.2 and HDL Coder 25.2
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: prediction_v2_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.prediction_v2_fixpt_pkg.ALL;
USE work.prediction_v2_fixpt_tb_pkg.ALL;

ENTITY prediction_v2_fixpt_tb IS
END prediction_v2_fixpt_tb;


ARCHITECTURE rtl OF prediction_v2_fixpt_tb IS

  -- Component Declarations
  COMPONENT prediction_v2_fixpt
    PORT( x                               :   IN    vector_of_std_logic_vector14(0 TO 20);  -- ufix14_En13 [21]
          w0                              :   IN    vector_of_std_logic_vector14(0 TO 9);  -- sfix14_En9 [10]
          b0                              :   IN    vector_of_std_logic_vector14(0 TO 9);  -- sfix14_En9 [10]
          w1                              :   IN    vector_of_std_logic_vector14(0 TO 9);  -- sfix14_En13 [10]
          b1                              :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En16
          y                               :   OUT   vector_of_std_logic_vector14(0 TO 20);  -- sfix14_En17 [21]
          dydx                            :   OUT   vector_of_std_logic_vector14(0 TO 20);  -- sfix14_En14 [21]
          d2ydx2                          :   OUT   vector_of_std_logic_vector14(0 TO 20);  -- sfix14_En12 [21]
          y0                              :   OUT   std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
          y1                              :   OUT   std_logic_vector(13 DOWNTO 0)  -- sfix14_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : prediction_v2_fixpt
    USE ENTITY work.prediction_v2_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL y_addr                           : std_logic;  -- ufix1
  SIGNAL y_lastAddr                       : std_logic;  -- ufix1
  SIGNAL dydx_addr                        : std_logic;  -- ufix1
  SIGNAL dydx_lastAddr                    : std_logic;  -- ufix1
  SIGNAL d2ydx2_addr                      : std_logic;  -- ufix1
  SIGNAL d2ydx2_lastAddr                  : std_logic;  -- ufix1
  SIGNAL y0_addr                          : std_logic;  -- ufix1
  SIGNAL y0_lastAddr                      : std_logic;  -- ufix1
  SIGNAL y1_addr                          : std_logic;  -- ufix1
  SIGNAL y1_lastAddr                      : std_logic;  -- ufix1
  SIGNAL y1_done                          : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL y1_done_enb                      : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL y0_done                          : std_logic;  -- ufix1
  SIGNAL y0_done_enb                      : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL d2ydx2_done                      : std_logic;  -- ufix1
  SIGNAL d2ydx2_done_enb                  : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL dydx_done                        : std_logic;  -- ufix1
  SIGNAL dydx_done_enb                    : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL tb_enb                           : std_logic;
  SIGNAL y_done                           : std_logic;  -- ufix1
  SIGNAL y_done_enb                       : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL ce_out                           : std_logic;
  SIGNAL rawData_x                        : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL holdData_x                       : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL rawData_w0                       : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL holdData_w0                      : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL rawData_b0                       : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL holdData_b0                      : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL rawData_w1                       : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL holdData_w1                      : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL rawData_b1                       : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL holdData_b1                      : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL x_offset                         : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL x_1                              : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL x_2                              : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL w0_offset                        : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL w0_1                             : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL w0_2                             : vector_of_std_logic_vector14(0 TO 9);  -- ufix14 [10]
  SIGNAL b0_offset                        : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL b0_1                             : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL b0_2                             : vector_of_std_logic_vector14(0 TO 9);  -- ufix14 [10]
  SIGNAL w1_offset                        : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL w1_1                             : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL w1_2                             : vector_of_std_logic_vector14(0 TO 9);  -- ufix14 [10]
  SIGNAL b1_offset                        : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL b1_1                             : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL b1_2                             : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y                                : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL dydx                             : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL d2ydx2                           : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL y0                               : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y1                               : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y_signed                         : vector_of_signed14(0 TO 20);  -- sfix14_En17 [21]
  SIGNAL y_expected_1                     : vector_of_signed14(0 TO 20);  -- sfix14_En17 [21]
  SIGNAL y_ref                            : vector_of_signed14(0 TO 20);  -- sfix14_En17 [21]
  SIGNAL y_testFailure                    : std_logic;  -- ufix1
  SIGNAL dydx_signed                      : vector_of_signed14(0 TO 20);  -- sfix14_En14 [21]
  SIGNAL dydx_expected_1                  : vector_of_signed14(0 TO 20);  -- sfix14_En14 [21]
  SIGNAL dydx_ref                         : vector_of_signed14(0 TO 20);  -- sfix14_En14 [21]
  SIGNAL dydx_testFailure                 : std_logic;  -- ufix1
  SIGNAL d2ydx2_signed                    : vector_of_signed14(0 TO 20);  -- sfix14_En12 [21]
  SIGNAL d2ydx2_expected_1                : vector_of_signed14(0 TO 20);  -- sfix14_En12 [21]
  SIGNAL d2ydx2_ref                       : vector_of_signed14(0 TO 20);  -- sfix14_En12 [21]
  SIGNAL d2ydx2_testFailure               : std_logic;  -- ufix1
  SIGNAL y0_signed                        : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y0_expected_1                    : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y0_ref                           : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y0_testFailure                   : std_logic;  -- ufix1
  SIGNAL y1_signed                        : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y1_expected_1                    : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y1_ref                           : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y1_testFailure                   : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_prediction_v2_fixpt : prediction_v2_fixpt
    PORT MAP( x => x_2,  -- ufix14_En13 [21]
              w0 => w0_2,  -- sfix14_En9 [10]
              b0 => b0_2,  -- sfix14_En9 [10]
              w1 => w1_2,  -- sfix14_En13 [10]
              b1 => b1_2,  -- sfix14_En16
              y => y,  -- sfix14_En17 [21]
              dydx => dydx,  -- sfix14_En14 [21]
              d2ydx2 => d2ydx2,  -- sfix14_En12 [21]
              y0 => y0,  -- sfix14_En12
              y1 => y1  -- sfix14_En12
              );

  y_lastAddr <= '1';

  dydx_lastAddr <= '1';

  d2ydx2_lastAddr <= '1';

  y0_lastAddr <= '1';

  y1_lastAddr <= '1';

  y1_done_enb <= y1_done AND rdEnb;

  y1_done <= y1_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check5_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y1_done_enb = '1' THEN
        check5_done <= y1_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  y0_done_enb <= y0_done AND rdEnb;

  y0_done <= y0_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check4_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y0_done_enb = '1' THEN
        check4_done <= y0_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  d2ydx2_done_enb <= d2ydx2_done AND rdEnb;

  d2ydx2_done <= d2ydx2_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF d2ydx2_done_enb = '1' THEN
        check3_done <= d2ydx2_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  dydx_done_enb <= dydx_done AND rdEnb;

  dydx_done <= dydx_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF dydx_done_enb = '1' THEN
        check2_done <= dydx_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  snkDonen <=  NOT snkDone;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  y_done_enb <= y_done AND rdEnb;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  resetn <=  NOT reset;

  y_done <= y_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y_done_enb = '1' THEN
        check1_done <= y_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done)));

  enb <= rdEnb AFTER 2 ns;

  ce_out <= enb AND (rdEnb AND tb_enb);

  -- Data source for x
  rawData_x(0) <= to_unsigned(16#0000#, 14);
  rawData_x(1) <= to_unsigned(16#0199#, 14);
  rawData_x(2) <= to_unsigned(16#0333#, 14);
  rawData_x(3) <= to_unsigned(16#04CC#, 14);
  rawData_x(4) <= to_unsigned(16#0666#, 14);
  rawData_x(5) <= to_unsigned(16#0800#, 14);
  rawData_x(6) <= to_unsigned(16#0999#, 14);
  rawData_x(7) <= to_unsigned(16#0B33#, 14);
  rawData_x(8) <= to_unsigned(16#0CCC#, 14);
  rawData_x(9) <= to_unsigned(16#0E66#, 14);
  rawData_x(10) <= to_unsigned(16#1000#, 14);
  rawData_x(11) <= to_unsigned(16#1199#, 14);
  rawData_x(12) <= to_unsigned(16#1333#, 14);
  rawData_x(13) <= to_unsigned(16#14CC#, 14);
  rawData_x(14) <= to_unsigned(16#1666#, 14);
  rawData_x(15) <= to_unsigned(16#1800#, 14);
  rawData_x(16) <= to_unsigned(16#1999#, 14);
  rawData_x(17) <= to_unsigned(16#1B33#, 14);
  rawData_x(18) <= to_unsigned(16#1CCC#, 14);
  rawData_x(19) <= to_unsigned(16#1E66#, 14);
  rawData_x(20) <= to_unsigned(16#2000#, 14);

  -- holdData reg for x
  stimuli_x_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_x <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_x <= rawData_x;
    END IF;
  END PROCESS stimuli_x_process;

  -- Data source for w0
  rawData_w0(0) <= to_signed(16#001C#, 14);
  rawData_w0(1) <= to_signed(-16#0C9D#, 14);
  rawData_w0(2) <= to_signed(-16#12BD#, 14);
  rawData_w0(3) <= to_signed(-16#0919#, 14);
  rawData_w0(4) <= to_signed(-16#04E5#, 14);
  rawData_w0(5) <= to_signed(-16#0046#, 14);
  rawData_w0(6) <= to_signed(16#01B7#, 14);
  rawData_w0(7) <= to_signed(16#022E#, 14);
  rawData_w0(8) <= to_signed(16#006A#, 14);
  rawData_w0(9) <= to_signed(-16#0670#, 14);

  -- holdData reg for w0
  stimuli_w0_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_w0 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_w0 <= rawData_w0;
    END IF;
  END PROCESS stimuli_w0_process;

  -- Data source for b0
  rawData_b0(0) <= to_signed(16#03F6#, 14);
  rawData_b0(1) <= to_signed(16#0C55#, 14);
  rawData_b0(2) <= to_signed(16#16EA#, 14);
  rawData_b0(3) <= to_signed(16#06A7#, 14);
  rawData_b0(4) <= to_signed(-16#03FB#, 14);
  rawData_b0(5) <= to_signed(-16#0056#, 14);
  rawData_b0(6) <= to_signed(16#010C#, 14);
  rawData_b0(7) <= to_signed(16#042B#, 14);
  rawData_b0(8) <= to_signed(16#0081#, 14);
  rawData_b0(9) <= to_signed(16#0BF1#, 14);

  -- holdData reg for b0
  stimuli_b0_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_b0 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_b0 <= rawData_b0;
    END IF;
  END PROCESS stimuli_b0_process;

  -- Data source for w1
  rawData_w1(0) <= to_signed(-16#06FF#, 14);
  rawData_w1(1) <= to_signed(16#03E7#, 14);
  rawData_w1(2) <= to_signed(16#0C4C#, 14);
  rawData_w1(3) <= to_signed(16#00F9#, 14);
  rawData_w1(4) <= to_signed(16#03CD#, 14);
  rawData_w1(5) <= to_signed(16#0D4B#, 14);
  rawData_w1(6) <= to_signed(16#1048#, 14);
  rawData_w1(7) <= to_signed(16#0AB6#, 14);
  rawData_w1(8) <= to_signed(-16#067B#, 14);
  rawData_w1(9) <= to_signed(-16#1FAE#, 14);

  -- holdData reg for w1
  stimuli_w1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_w1 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_w1 <= rawData_w1;
    END IF;
  END PROCESS stimuli_w1_process;

  -- Data source for b1
  rawData_b1 <= to_signed(-16#1063#, 14);

  -- holdData reg for b1
  stimuli_b1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_b1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_b1 <= rawData_b1;
    END IF;
  END PROCESS stimuli_b1_process;

  stimuli_x_1: PROCESS (rawData_x, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      x_offset <= holdData_x;
    ELSE
      x_offset <= rawData_x;
    END IF;
  END PROCESS stimuli_x_1;

  x_1 <= x_offset AFTER 2 ns;

  outputgen6: FOR k IN 0 TO 20 GENERATE
    x_2(k) <= std_logic_vector(x_1(k));
  END GENERATE;

  stimuli_w0_1: PROCESS (rawData_w0, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      w0_offset <= holdData_w0;
    ELSE
      w0_offset <= rawData_w0;
    END IF;
  END PROCESS stimuli_w0_1;

  w0_1 <= w0_offset AFTER 2 ns;

  outputgen5: FOR k IN 0 TO 9 GENERATE
    w0_2(k) <= std_logic_vector(w0_1(k));
  END GENERATE;

  stimuli_b0_1: PROCESS (rawData_b0, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      b0_offset <= holdData_b0;
    ELSE
      b0_offset <= rawData_b0;
    END IF;
  END PROCESS stimuli_b0_1;

  b0_1 <= b0_offset AFTER 2 ns;

  outputgen4: FOR k IN 0 TO 9 GENERATE
    b0_2(k) <= std_logic_vector(b0_1(k));
  END GENERATE;

  stimuli_w1_1: PROCESS (rawData_w1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      w1_offset <= holdData_w1;
    ELSE
      w1_offset <= rawData_w1;
    END IF;
  END PROCESS stimuli_w1_1;

  w1_1 <= w1_offset AFTER 2 ns;

  outputgen3: FOR k IN 0 TO 9 GENERATE
    w1_2(k) <= std_logic_vector(w1_1(k));
  END GENERATE;

  stimuli_b1_1: PROCESS (rawData_b1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      b1_offset <= holdData_b1;
    ELSE
      b1_offset <= rawData_b1;
    END IF;
  END PROCESS stimuli_b1_1;

  b1_1 <= b1_offset AFTER 2 ns;

  b1_2 <= std_logic_vector(b1_1);

  outputgen2: FOR k IN 0 TO 20 GENERATE
    y_signed(k) <= signed(y(k));
  END GENERATE;

  -- Data source for y_expected
  y_expected_1(0) <= to_signed(-16#00C6#, 14);
  y_expected_1(1) <= to_signed(16#015A#, 14);
  y_expected_1(2) <= to_signed(16#033A#, 14);
  y_expected_1(3) <= to_signed(16#055A#, 14);
  y_expected_1(4) <= to_signed(16#077A#, 14);
  y_expected_1(5) <= to_signed(16#095A#, 14);
  y_expected_1(6) <= to_signed(16#0B3A#, 14);
  y_expected_1(7) <= to_signed(16#0D5A#, 14);
  y_expected_1(8) <= to_signed(16#0EFA#, 14);
  y_expected_1(9) <= to_signed(16#10BA#, 14);
  y_expected_1(10) <= to_signed(16#121A#, 14);
  y_expected_1(11) <= to_signed(16#133A#, 14);
  y_expected_1(12) <= to_signed(16#13FA#, 14);
  y_expected_1(13) <= to_signed(16#143A#, 14);
  y_expected_1(14) <= to_signed(16#143A#, 14);
  y_expected_1(15) <= to_signed(16#137A#, 14);
  y_expected_1(16) <= to_signed(16#11DA#, 14);
  y_expected_1(17) <= to_signed(16#0F3A#, 14);
  y_expected_1(18) <= to_signed(16#0B5A#, 14);
  y_expected_1(19) <= to_signed(16#061A#, 14);
  y_expected_1(20) <= to_signed(-16#0126#, 14);

  y_ref <= y_expected_1;

  y_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND y_signed /= y_ref THEN
        y_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y_signed: Expected " & to_hex(y_ref) & (" Actual " & to_hex(y_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y_signed_checker;

  outputgen1: FOR k IN 0 TO 20 GENERATE
    dydx_signed(k) <= signed(dydx(k));
  END GENERATE;

  -- Data source for dydx_expected
  dydx_expected_1(0) <= to_signed(16#0544#, 14);
  dydx_expected_1(1) <= to_signed(16#0546#, 14);
  dydx_expected_1(2) <= to_signed(16#0540#, 14);
  dydx_expected_1(3) <= to_signed(16#052E#, 14);
  dydx_expected_1(4) <= to_signed(16#0514#, 14);
  dydx_expected_1(5) <= to_signed(16#04EE#, 14);
  dydx_expected_1(6) <= to_signed(16#04B8#, 14);
  dydx_expected_1(7) <= to_signed(16#0476#, 14);
  dydx_expected_1(8) <= to_signed(16#0420#, 14);
  dydx_expected_1(9) <= to_signed(16#03B0#, 14);
  dydx_expected_1(10) <= to_signed(16#031E#, 14);
  dydx_expected_1(11) <= to_signed(16#0266#, 14);
  dydx_expected_1(12) <= to_signed(16#017A#, 14);
  dydx_expected_1(13) <= to_signed(16#0058#, 14);
  dydx_expected_1(14) <= to_signed(-16#011C#, 14);
  dydx_expected_1(15) <= to_signed(-16#02DC#, 14);
  dydx_expected_1(16) <= to_signed(-16#0516#, 14);
  dydx_expected_1(17) <= to_signed(-16#07D4#, 14);
  dydx_expected_1(18) <= to_signed(-16#0B4C#, 14);
  dydx_expected_1(19) <= to_signed(-16#0FBA#, 14);
  dydx_expected_1(20) <= to_signed(-16#1560#, 14);

  dydx_ref <= dydx_expected_1;

  dydx_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dydx_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND dydx_signed /= dydx_ref THEN
        dydx_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in dydx_signed: Expected " & to_hex(dydx_ref) & (" Actual " & to_hex(dydx_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS dydx_signed_checker;

  outputgen: FOR k IN 0 TO 20 GENERATE
    d2ydx2_signed(k) <= signed(d2ydx2(k));
  END GENERATE;

  -- Data source for d2ydx2_expected
  d2ydx2_expected_1(0) <= to_signed(-16#0016#, 14);
  d2ydx2_expected_1(1) <= to_signed(-16#0030#, 14);
  d2ydx2_expected_1(2) <= to_signed(-16#0050#, 14);
  d2ydx2_expected_1(3) <= to_signed(-16#007A#, 14);
  d2ydx2_expected_1(4) <= to_signed(-16#00AC#, 14);
  d2ydx2_expected_1(5) <= to_signed(-16#00E8#, 14);
  d2ydx2_expected_1(6) <= to_signed(-16#013A#, 14);
  d2ydx2_expected_1(7) <= to_signed(-16#0194#, 14);
  d2ydx2_expected_1(8) <= to_signed(-16#0200#, 14);
  d2ydx2_expected_1(9) <= to_signed(-16#0286#, 14);
  d2ydx2_expected_1(10) <= to_signed(-16#033E#, 14);
  d2ydx2_expected_1(11) <= to_signed(-16#040A#, 14);
  d2ydx2_expected_1(12) <= to_signed(-16#0528#, 14);
  d2ydx2_expected_1(13) <= to_signed(-16#0672#, 14);
  d2ydx2_expected_1(14) <= to_signed(-16#0810#, 14);
  d2ydx2_expected_1(15) <= to_signed(-16#09F0#, 14);
  d2ydx2_expected_1(16) <= to_signed(-16#0C5C#, 14);
  d2ydx2_expected_1(17) <= to_signed(-16#0F7C#, 14);
  d2ydx2_expected_1(18) <= to_signed(-16#13A8#, 14);
  d2ydx2_expected_1(19) <= to_signed(-16#192C#, 14);
  d2ydx2_expected_1(20) <= to_signed(-16#1F82#, 14);

  d2ydx2_ref <= d2ydx2_expected_1;

  d2ydx2_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      d2ydx2_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND d2ydx2_signed /= d2ydx2_ref THEN
        d2ydx2_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in d2ydx2_signed: Expected " & to_hex(d2ydx2_ref) & (" Actual " & to_hex(d2ydx2_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS d2ydx2_signed_checker;

  y0_signed <= signed(y0);

  -- Data source for y0_expected
  y0_expected_1 <= to_signed(-16#0007#, 14);

  y0_ref <= y0_expected_1;

  y0_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y0_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND y0_signed /= y0_ref THEN
        y0_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y0_signed: Expected " & to_hex(y0_ref) & (" Actual " & to_hex(y0_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y0_signed_checker;

  y1_signed <= signed(y1);

  -- Data source for y1_expected
  y1_expected_1 <= to_signed(-16#0009#, 14);

  y1_ref <= y1_expected_1;

  y1_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y1_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND y1_signed /= y1_ref THEN
        y1_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y1_signed: Expected " & to_hex(y1_ref) & (" Actual " & to_hex(y1_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y1_signed_checker;

  testFailure <= y1_testFailure OR (y0_testFailure OR (d2ydx2_testFailure OR (y_testFailure OR dydx_testFailure)));

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

