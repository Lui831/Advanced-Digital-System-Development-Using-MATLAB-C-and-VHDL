-- -------------------------------------------------------------
-- 
-- File Name: C:\ex_PINN_Matlab\codegen\prediction_v2\hdlsrc\prediction_v2_fixpt_tb.vhd
-- Created: 2025-11-19 07:52:42
-- 
-- Generated by MATLAB 25.2, MATLAB Coder 25.2 and HDL Coder 25.2
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: prediction_v2_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.prediction_v2_fixpt_pkg.ALL;
USE work.prediction_v2_fixpt_tb_pkg.ALL;

ENTITY prediction_v2_fixpt_tb IS
END prediction_v2_fixpt_tb;


ARCHITECTURE rtl OF prediction_v2_fixpt_tb IS

  -- Component Declarations
  COMPONENT prediction_v2_fixpt
    PORT( x                               :   IN    vector_of_std_logic_vector14(0 TO 20);  -- ufix14_En13 [21]
          w0                              :   IN    vector_of_std_logic_vector14(0 TO 9);  -- sfix14_En9 [10]
          b0                              :   IN    vector_of_std_logic_vector14(0 TO 9);  -- sfix14_En9 [10]
          w1                              :   IN    vector_of_std_logic_vector14(0 TO 9);  -- sfix14_En13 [10]
          b1                              :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En16
          y                               :   OUT   vector_of_std_logic_vector14(0 TO 20);  -- sfix14_En17 [21]
          dydx                            :   OUT   vector_of_std_logic_vector14(0 TO 20);  -- sfix14_En14 [21]
          d2ydx2                          :   OUT   vector_of_std_logic_vector14(0 TO 20);  -- sfix14_En11 [21]
          y0                              :   OUT   std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
          y1                              :   OUT   std_logic_vector(13 DOWNTO 0)  -- sfix14_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : prediction_v2_fixpt
    USE ENTITY work.prediction_v2_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL y1_done                          : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL y1_done_enb                      : std_logic;  -- ufix1
  SIGNAL y_addr                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL y1_lastAddr                      : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL y0_done                          : std_logic;  -- ufix1
  SIGNAL y0_done_enb                      : std_logic;  -- ufix1
  SIGNAL y0_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL d2ydx2_done                      : std_logic;  -- ufix1
  SIGNAL d2ydx2_done_enb                  : std_logic;  -- ufix1
  SIGNAL d2ydx2_lastAddr                  : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL dydx_done                        : std_logic;  -- ufix1
  SIGNAL dydx_done_enb                    : std_logic;  -- ufix1
  SIGNAL dydx_lastAddr                    : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL y_done                           : std_logic;  -- ufix1
  SIGNAL y_done_enb                       : std_logic;  -- ufix1
  SIGNAL y_active                         : std_logic;  -- ufix1
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL tb_enb                           : std_logic;
  SIGNAL ce_out                           : std_logic;
  SIGNAL y_enb                            : std_logic;  -- ufix1
  SIGNAL y_lastAddr                       : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL rawData_x                        : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL holdData_x                       : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL x_addr                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL x_active                         : std_logic;  -- ufix1
  SIGNAL x_enb                            : std_logic;  -- ufix1
  SIGNAL w0_addr_delay_1                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rawData_w0                       : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL holdData_w0                      : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL b0_addr_delay_1                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rawData_b0                       : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL holdData_b0                      : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL w1_addr_delay_1                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rawData_w1                       : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL holdData_w1                      : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL b1_addr_delay_1                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rawData_b1                       : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL holdData_b1                      : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL x_offset                         : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL x_2                              : vector_of_unsigned14(0 TO 20);  -- ufix14_En13 [21]
  SIGNAL x_3                              : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL w0_offset                        : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL w0                               : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL w0_1                             : vector_of_std_logic_vector14(0 TO 9);  -- ufix14 [10]
  SIGNAL b0_offset                        : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL b0                               : vector_of_signed14(0 TO 9);  -- sfix14_En9 [10]
  SIGNAL b0_1                             : vector_of_std_logic_vector14(0 TO 9);  -- ufix14 [10]
  SIGNAL w1_offset                        : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL w1                               : vector_of_signed14(0 TO 9);  -- sfix14_En13 [10]
  SIGNAL w1_1                             : vector_of_std_logic_vector14(0 TO 9);  -- ufix14 [10]
  SIGNAL b1_offset                        : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL b1                               : signed(13 DOWNTO 0);  -- sfix14_En16
  SIGNAL b1_1                             : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y_1                              : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL dydx                             : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL d2ydx2                           : vector_of_std_logic_vector14(0 TO 20);  -- ufix14 [21]
  SIGNAL y0                               : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y1                               : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y_signed                         : vector_of_signed14(0 TO 20);  -- sfix14_En17 [21]
  SIGNAL y_addr_delay_1                   : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL y_expected                       : vector_of_signed14(0 TO 20);  -- sfix14_En17 [21]
  SIGNAL y_ref                            : vector_of_signed14(0 TO 20);  -- sfix14_En17 [21]
  SIGNAL y_testFailure                    : std_logic;  -- ufix1
  SIGNAL dydx_signed                      : vector_of_signed14(0 TO 20);  -- sfix14_En14 [21]
  SIGNAL dydx_addr_delay_1                : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL dydx_expected                    : vector_of_signed14(0 TO 20);  -- sfix14_En14 [21]
  SIGNAL dydx_ref                         : vector_of_signed14(0 TO 20);  -- sfix14_En14 [21]
  SIGNAL dydx_testFailure                 : std_logic;  -- ufix1
  SIGNAL d2ydx2_signed                    : vector_of_signed14(0 TO 20);  -- sfix14_En11 [21]
  SIGNAL d2ydx2_addr_delay_1              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL d2ydx2_expected                  : vector_of_signed14(0 TO 20);  -- sfix14_En11 [21]
  SIGNAL d2ydx2_ref                       : vector_of_signed14(0 TO 20);  -- sfix14_En11 [21]
  SIGNAL d2ydx2_testFailure               : std_logic;  -- ufix1
  SIGNAL y0_signed                        : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y0_addr_delay_1                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL y0_expected                      : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y0_ref                           : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y0_testFailure                   : std_logic;  -- ufix1
  SIGNAL y1_signed                        : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y1_addr_delay_1                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL y1_expected                      : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y1_ref                           : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL y1_testFailure                   : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_prediction_v2_fixpt : prediction_v2_fixpt
    PORT MAP( x => x_3,  -- ufix14_En13 [21]
              w0 => w0_1,  -- sfix14_En9 [10]
              b0 => b0_1,  -- sfix14_En9 [10]
              w1 => w1_1,  -- sfix14_En13 [10]
              b1 => b1_1,  -- sfix14_En16
              y => y_1,  -- sfix14_En17 [21]
              dydx => dydx,  -- sfix14_En14 [21]
              d2ydx2 => d2ydx2,  -- sfix14_En11 [21]
              y0 => y0,  -- sfix14_En12
              y1 => y1  -- sfix14_En12
              );

  y1_done_enb <= y1_done AND rdEnb;

  
  y1_lastAddr <= '1' WHEN y_addr >= to_unsigned(16#7D2#, 11) ELSE
      '0';

  y1_done <= y1_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check5_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y1_done_enb = '1' THEN
        check5_done <= y1_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  y0_done_enb <= y0_done AND rdEnb;

  
  y0_lastAddr <= '1' WHEN y_addr >= to_unsigned(16#7D2#, 11) ELSE
      '0';

  y0_done <= y0_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check4_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y0_done_enb = '1' THEN
        check4_done <= y0_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  d2ydx2_done_enb <= d2ydx2_done AND rdEnb;

  
  d2ydx2_lastAddr <= '1' WHEN y_addr >= to_unsigned(16#7D2#, 11) ELSE
      '0';

  d2ydx2_done <= d2ydx2_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF d2ydx2_done_enb = '1' THEN
        check3_done <= d2ydx2_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  dydx_done_enb <= dydx_done AND rdEnb;

  
  dydx_lastAddr <= '1' WHEN y_addr >= to_unsigned(16#7D2#, 11) ELSE
      '0';

  dydx_done <= dydx_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF dydx_done_enb = '1' THEN
        check2_done <= dydx_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  y_done_enb <= y_done AND rdEnb;

  
  y_active <= '1' WHEN y_addr /= to_unsigned(16#7D2#, 11) ELSE
      '0';

  enb <= rdEnb AFTER 2 ns;

  snkDonen <=  NOT snkDone;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  resetn <=  NOT reset;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  ce_out <= enb AND (rdEnb AND tb_enb);

  y_enb <= ce_out AND y_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2002
  y_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y_addr <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF y_enb = '1' THEN
        IF y_addr >= to_unsigned(16#7D2#, 11) THEN 
          y_addr <= to_unsigned(16#000#, 11);
        ELSE 
          y_addr <= y_addr + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS y_process;


  
  y_lastAddr <= '1' WHEN y_addr >= to_unsigned(16#7D2#, 11) ELSE
      '0';

  y_done <= y_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y_done_enb = '1' THEN
        check1_done <= y_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done)));

  -- Data source for x
  rawData_x(0) <= to_unsigned(16#0000#, 14);
  rawData_x(1) <= to_unsigned(16#0199#, 14);
  rawData_x(2) <= to_unsigned(16#0333#, 14);
  rawData_x(3) <= to_unsigned(16#04CC#, 14);
  rawData_x(4) <= to_unsigned(16#0666#, 14);
  rawData_x(5) <= to_unsigned(16#0800#, 14);
  rawData_x(6) <= to_unsigned(16#0999#, 14);
  rawData_x(7) <= to_unsigned(16#0B33#, 14);
  rawData_x(8) <= to_unsigned(16#0CCC#, 14);
  rawData_x(9) <= to_unsigned(16#0E66#, 14);
  rawData_x(10) <= to_unsigned(16#1000#, 14);
  rawData_x(11) <= to_unsigned(16#1199#, 14);
  rawData_x(12) <= to_unsigned(16#1333#, 14);
  rawData_x(13) <= to_unsigned(16#14CC#, 14);
  rawData_x(14) <= to_unsigned(16#1666#, 14);
  rawData_x(15) <= to_unsigned(16#1800#, 14);
  rawData_x(16) <= to_unsigned(16#1999#, 14);
  rawData_x(17) <= to_unsigned(16#1B33#, 14);
  rawData_x(18) <= to_unsigned(16#1CCC#, 14);
  rawData_x(19) <= to_unsigned(16#1E66#, 14);
  rawData_x(20) <= to_unsigned(16#2000#, 14);

  -- holdData reg for x
  stimuli_x_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_x <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_x <= rawData_x;
    END IF;
  END PROCESS stimuli_x_process;

  
  x_active <= '1' WHEN x_addr /= to_unsigned(16#7D2#, 11) ELSE
      '0';

  x_enb <= x_active AND (rdEnb AND tb_enb);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2002
  x_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      x_addr <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF x_enb = '1' THEN
        IF x_addr >= to_unsigned(16#7D2#, 11) THEN 
          x_addr <= to_unsigned(16#000#, 11);
        ELSE 
          x_addr <= x_addr + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS x_1_process;


  w0_addr_delay_1 <= x_addr AFTER 1 ns;

  -- Data source for w0
  w0_fileread: PROCESS (w0_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "w0.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: vector_of_std_logic_vector16(0 TO 9);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      FOR k0 IN 0 TO 9 LOOP
        HREAD(l, read_data(k0));
      END LOOP;
    END IF;
    rawData_w0 <= (signed(read_data(0)(13 DOWNTO 0)), signed(read_data(1)(13 DOWNTO 0)), signed(read_data(2)(13 DOWNTO 0)), signed(read_data(3)(13 DOWNTO 0)), signed(read_data(4)(13 DOWNTO 0)), signed(read_data(5)(13 DOWNTO 0)), signed(read_data(6)(13 DOWNTO 0)), signed(read_data(7)(13 DOWNTO 0)), signed(read_data(8)(13 DOWNTO 0)), signed(read_data(9)(13 DOWNTO 0)));
  END PROCESS w0_fileread;

  -- holdData reg for w0
  stimuli_w0_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_w0 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_w0 <= rawData_w0;
    END IF;
  END PROCESS stimuli_w0_process;

  b0_addr_delay_1 <= x_addr AFTER 1 ns;

  -- Data source for b0
  b0_fileread: PROCESS (b0_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "b0.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: vector_of_std_logic_vector16(0 TO 9);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      FOR k0 IN 0 TO 9 LOOP
        HREAD(l, read_data(k0));
      END LOOP;
    END IF;
    rawData_b0 <= (signed(read_data(0)(13 DOWNTO 0)), signed(read_data(1)(13 DOWNTO 0)), signed(read_data(2)(13 DOWNTO 0)), signed(read_data(3)(13 DOWNTO 0)), signed(read_data(4)(13 DOWNTO 0)), signed(read_data(5)(13 DOWNTO 0)), signed(read_data(6)(13 DOWNTO 0)), signed(read_data(7)(13 DOWNTO 0)), signed(read_data(8)(13 DOWNTO 0)), signed(read_data(9)(13 DOWNTO 0)));
  END PROCESS b0_fileread;

  -- holdData reg for b0
  stimuli_b0_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_b0 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_b0 <= rawData_b0;
    END IF;
  END PROCESS stimuli_b0_process;

  w1_addr_delay_1 <= x_addr AFTER 1 ns;

  -- Data source for w1
  w1_fileread: PROCESS (w1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "w1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: vector_of_std_logic_vector16(0 TO 9);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      FOR k0 IN 0 TO 9 LOOP
        HREAD(l, read_data(k0));
      END LOOP;
    END IF;
    rawData_w1 <= (signed(read_data(0)(13 DOWNTO 0)), signed(read_data(1)(13 DOWNTO 0)), signed(read_data(2)(13 DOWNTO 0)), signed(read_data(3)(13 DOWNTO 0)), signed(read_data(4)(13 DOWNTO 0)), signed(read_data(5)(13 DOWNTO 0)), signed(read_data(6)(13 DOWNTO 0)), signed(read_data(7)(13 DOWNTO 0)), signed(read_data(8)(13 DOWNTO 0)), signed(read_data(9)(13 DOWNTO 0)));
  END PROCESS w1_fileread;

  -- holdData reg for w1
  stimuli_w1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_w1 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_w1 <= rawData_w1;
    END IF;
  END PROCESS stimuli_w1_process;

  b1_addr_delay_1 <= x_addr AFTER 1 ns;

  -- Data source for b1
  b1_fileread: PROCESS (b1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "b1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_b1 <= signed(read_data(13 DOWNTO 0));
  END PROCESS b1_fileread;

  -- holdData reg for b1
  stimuli_b1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_b1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_b1 <= rawData_b1;
    END IF;
  END PROCESS stimuli_b1_process;

  stimuli_x_1: PROCESS (rawData_x, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      x_offset <= holdData_x;
    ELSE
      x_offset <= rawData_x;
    END IF;
  END PROCESS stimuli_x_1;

  x_2 <= x_offset AFTER 2 ns;

  outputgen6: FOR k IN 0 TO 20 GENERATE
    x_3(k) <= std_logic_vector(x_2(k));
  END GENERATE;

  stimuli_w0_1: PROCESS (rawData_w0, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      w0_offset <= holdData_w0;
    ELSE
      w0_offset <= rawData_w0;
    END IF;
  END PROCESS stimuli_w0_1;

  w0 <= w0_offset AFTER 2 ns;

  outputgen5: FOR k IN 0 TO 9 GENERATE
    w0_1(k) <= std_logic_vector(w0(k));
  END GENERATE;

  stimuli_b0_1: PROCESS (rawData_b0, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      b0_offset <= holdData_b0;
    ELSE
      b0_offset <= rawData_b0;
    END IF;
  END PROCESS stimuli_b0_1;

  b0 <= b0_offset AFTER 2 ns;

  outputgen4: FOR k IN 0 TO 9 GENERATE
    b0_1(k) <= std_logic_vector(b0(k));
  END GENERATE;

  stimuli_w1_1: PROCESS (rawData_w1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      w1_offset <= holdData_w1;
    ELSE
      w1_offset <= rawData_w1;
    END IF;
  END PROCESS stimuli_w1_1;

  w1 <= w1_offset AFTER 2 ns;

  outputgen3: FOR k IN 0 TO 9 GENERATE
    w1_1(k) <= std_logic_vector(w1(k));
  END GENERATE;

  stimuli_b1_1: PROCESS (rawData_b1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      b1_offset <= holdData_b1;
    ELSE
      b1_offset <= rawData_b1;
    END IF;
  END PROCESS stimuli_b1_1;

  b1 <= b1_offset AFTER 2 ns;

  b1_1 <= std_logic_vector(b1);

  outputgen2: FOR k IN 0 TO 20 GENERATE
    y_signed(k) <= signed(y_1(k));
  END GENERATE;

  y_addr_delay_1 <= y_addr AFTER 1 ns;

  -- Data source for y_expected
  y_expected_fileread: PROCESS (y_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "y_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: vector_of_std_logic_vector16(0 TO 20);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      FOR k0 IN 0 TO 20 LOOP
        HREAD(l, read_data(k0));
      END LOOP;
    END IF;
    y_expected <= (signed(read_data(0)(13 DOWNTO 0)), signed(read_data(1)(13 DOWNTO 0)), signed(read_data(2)(13 DOWNTO 0)), signed(read_data(3)(13 DOWNTO 0)), signed(read_data(4)(13 DOWNTO 0)), signed(read_data(5)(13 DOWNTO 0)), signed(read_data(6)(13 DOWNTO 0)), signed(read_data(7)(13 DOWNTO 0)), signed(read_data(8)(13 DOWNTO 0)), signed(read_data(9)(13 DOWNTO 0)), signed(read_data(10)(13 DOWNTO 0)), signed(read_data(11)(13 DOWNTO 0)), signed(read_data(12)(13 DOWNTO 0)), signed(read_data(13)(13 DOWNTO 0)), signed(read_data(14)(13 DOWNTO 0)), signed(read_data(15)(13 DOWNTO 0)), signed(read_data(16)(13 DOWNTO 0)), signed(read_data(17)(13 DOWNTO 0)), signed(read_data(18)(13 DOWNTO 0)), signed(read_data(19)(13 DOWNTO 0)), signed(read_data(20)(13 DOWNTO 0)));
  END PROCESS y_expected_fileread;

  y_ref <= y_expected;

  y_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND y_signed /= y_ref THEN
        y_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y_signed: Expected " & to_hex(y_ref) & (" Actual " & to_hex(y_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y_signed_checker;

  outputgen1: FOR k IN 0 TO 20 GENERATE
    dydx_signed(k) <= signed(dydx(k));
  END GENERATE;

  dydx_addr_delay_1 <= y_addr AFTER 1 ns;

  -- Data source for dydx_expected
  dydx_expected_fileread: PROCESS (dydx_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "dydx_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: vector_of_std_logic_vector16(0 TO 20);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      FOR k0 IN 0 TO 20 LOOP
        HREAD(l, read_data(k0));
      END LOOP;
    END IF;
    dydx_expected <= (signed(read_data(0)(13 DOWNTO 0)), signed(read_data(1)(13 DOWNTO 0)), signed(read_data(2)(13 DOWNTO 0)), signed(read_data(3)(13 DOWNTO 0)), signed(read_data(4)(13 DOWNTO 0)), signed(read_data(5)(13 DOWNTO 0)), signed(read_data(6)(13 DOWNTO 0)), signed(read_data(7)(13 DOWNTO 0)), signed(read_data(8)(13 DOWNTO 0)), signed(read_data(9)(13 DOWNTO 0)), signed(read_data(10)(13 DOWNTO 0)), signed(read_data(11)(13 DOWNTO 0)), signed(read_data(12)(13 DOWNTO 0)), signed(read_data(13)(13 DOWNTO 0)), signed(read_data(14)(13 DOWNTO 0)), signed(read_data(15)(13 DOWNTO 0)), signed(read_data(16)(13 DOWNTO 0)), signed(read_data(17)(13 DOWNTO 0)), signed(read_data(18)(13 DOWNTO 0)), signed(read_data(19)(13 DOWNTO 0)), signed(read_data(20)(13 DOWNTO 0)));
  END PROCESS dydx_expected_fileread;

  dydx_ref <= dydx_expected;

  dydx_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dydx_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND dydx_signed /= dydx_ref THEN
        dydx_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in dydx_signed: Expected " & to_hex(dydx_ref) & (" Actual " & to_hex(dydx_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS dydx_signed_checker;

  outputgen: FOR k IN 0 TO 20 GENERATE
    d2ydx2_signed(k) <= signed(d2ydx2(k));
  END GENERATE;

  d2ydx2_addr_delay_1 <= y_addr AFTER 1 ns;

  -- Data source for d2ydx2_expected
  d2ydx2_expected_fileread: PROCESS (d2ydx2_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "d2ydx2_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: vector_of_std_logic_vector16(0 TO 20);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      FOR k0 IN 0 TO 20 LOOP
        HREAD(l, read_data(k0));
      END LOOP;
    END IF;
    d2ydx2_expected <= (signed(read_data(0)(13 DOWNTO 0)), signed(read_data(1)(13 DOWNTO 0)), signed(read_data(2)(13 DOWNTO 0)), signed(read_data(3)(13 DOWNTO 0)), signed(read_data(4)(13 DOWNTO 0)), signed(read_data(5)(13 DOWNTO 0)), signed(read_data(6)(13 DOWNTO 0)), signed(read_data(7)(13 DOWNTO 0)), signed(read_data(8)(13 DOWNTO 0)), signed(read_data(9)(13 DOWNTO 0)), signed(read_data(10)(13 DOWNTO 0)), signed(read_data(11)(13 DOWNTO 0)), signed(read_data(12)(13 DOWNTO 0)), signed(read_data(13)(13 DOWNTO 0)), signed(read_data(14)(13 DOWNTO 0)), signed(read_data(15)(13 DOWNTO 0)), signed(read_data(16)(13 DOWNTO 0)), signed(read_data(17)(13 DOWNTO 0)), signed(read_data(18)(13 DOWNTO 0)), signed(read_data(19)(13 DOWNTO 0)), signed(read_data(20)(13 DOWNTO 0)));
  END PROCESS d2ydx2_expected_fileread;

  d2ydx2_ref <= d2ydx2_expected;

  d2ydx2_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      d2ydx2_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND d2ydx2_signed /= d2ydx2_ref THEN
        d2ydx2_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in d2ydx2_signed: Expected " & to_hex(d2ydx2_ref) & (" Actual " & to_hex(d2ydx2_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS d2ydx2_signed_checker;

  y0_signed <= signed(y0);

  y0_addr_delay_1 <= y_addr AFTER 1 ns;

  -- Data source for y0_expected
  y0_expected_fileread: PROCESS (y0_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "y0_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    y0_expected <= signed(read_data(13 DOWNTO 0));
  END PROCESS y0_expected_fileread;

  y0_ref <= y0_expected;

  y0_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y0_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND y0_signed /= y0_ref THEN
        y0_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y0_signed: Expected " & to_hex(y0_ref) & (" Actual " & to_hex(y0_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y0_signed_checker;

  y1_signed <= signed(y1);

  y1_addr_delay_1 <= y_addr AFTER 1 ns;

  -- Data source for y1_expected
  y1_expected_fileread: PROCESS (y1_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "y1_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    y1_expected <= signed(read_data(13 DOWNTO 0));
  END PROCESS y1_expected_fileread;

  y1_ref <= y1_expected;

  y1_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      y1_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND y1_signed /= y1_ref THEN
        y1_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y1_signed: Expected " & to_hex(y1_ref) & (" Actual " & to_hex(y1_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y1_signed_checker;

  testFailure <= y1_testFailure OR (y0_testFailure OR (d2ydx2_testFailure OR (y_testFailure OR dydx_testFailure)));

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

